
<!DOCTYPE html>
<meta charset="utf-8">
<style>

.feature {
    fill: #ccf9fb;
    stroke: #004447;
    stroke-width: 1px;
    stroke-linejoin: round;

  }

.mesh {
    fill: none;
      stroke: #004447;
      stroke-width: 1px;
      stroke-linejoin: round;
  }

 svg .path {
     stroke-width: 1px;
     stroke: magenta;
 }

</style>
<body>
<script src="//d3js.org/d3.v3.min.js" charset="utf-8"></script></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script>

 var width = 1000,
     height = 500;

 var rc = [-74.0031909, 40.7206499];
 var homea = [-73.9970746, 40.6999351];
 var homed = [-74.0496805, 40.71692];

 var projection = d3.geo.mercator()
                    .center([-73.94, 40.70])
                    .scale(80000)
                    .translate([width / 2, height / 2]);

 var path = d3.geo.path()
              .projection(projection);

 var svg = d3.select("body").append("svg")
             .attr("width", width)
             .attr("height", height);

d3.json("/working/encoded-topo2.json", function(error, nyc) {
     svg.append("path")
        .datum(topojson.feature(nyc, nyc.objects.encoded2))
        .attr("d", path)
        .attr("class", "feature");

     svg.append("path")
        .datum(topojson.mesh(nyc, nyc.objects.encoded2, function(a, b) { return a !== b; }))
        .attr("class", "mesh")
        .attr("d", path);

     svg.selectAll("circle")
        .data([rc]).enter()
        .append("circle")
        .attr("cx", function (d) { return projection(d)[0];})
        .attr("cy", function (d) { return projection(d)[1]; })
        .attr("r", "4px")
        .attr("fill", "green");

     /* TODO why does the first circle not get graphed? */
     svg.selectAll("circle")
        .data([homed, homea]).enter()
        .append("circle")
        .attr("cx", function (d) { return projection(d)[0];})
        .attr("cy", function (d) { return projection(d)[1]; })
        .attr("r", "4px")
        .attr("fill", "orange");


     d3.json("stations.json", function(error, stations) {
         svg.selectAll("circle")
            .data(stations).enter()
            .append("circle")
            .attr("cx", function(d) { p = projection([d['long'], d['lat']]); return p[0]; })
            .attr("cy", function(d) { p = projection([d['long'], d['lat']]); return p[1]; })
            .attr("r", "1px")
            .attr("fill","pink");
     });

     d3.json("bike.json", function(error, bike) {
        var pathLine = d3.svg.line()
            .x(function(d) { p = projection(d); console.log(d); return p[0]; })
            .y(function(d) { p = projection(d); return p[1]; });

         
         var patha = svg.selectAll("line")

            .data(bike).enter()
            .append("path")
            .attr("d",  function(d) {return pathLine([[d.start_long, d.start_lat], [d.end_long, d.end_lat]]);})
           
            .attr("class", "path")
            .transition()
            .duration(2000)

            ;


    //It is calculating the wrong lenght and it needs to calculate each length.

        // var totalLength = patha.node().getTotalLength();
            
            patha
            .each(function(d) { d.totalLength = this.getTotalLength(); })
            .attr("stroke-dasharray", function(d) { console.log(d.totalLength); return d.totalLength + " " + d.totalLength})
            .attr("stroke-dashoffset", function(d) { return d.totalLength; })
            //.style("opacity", 1)
            .transition()

            .duration(function(d){return d.totalLength * 50})
            //.style("opacity", 0)
            .ease("linear")
            .attr("stroke-dashoffset", 0);

            



     });
 });





</script>
